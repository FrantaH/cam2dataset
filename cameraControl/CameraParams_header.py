# -*- coding: utf-8 -*-
# generated by 'xml2py'
# flags '-c -d -v C:\test_h\CameraParams.xml -o CameraParams_header.py'
from ctypes import *
from cameraControl.CameraParams_const import *
from cameraControl.PixelType_header import *

STRING = c_char_p

MV_PointCloudFile_Undefined = 0                  # <  Undefined point cloud format
MV_ACQ_MODE_CONTINUOUS = 2                       # <  Continuous Mode
MV_ACQ_MODE_MUTLI = 1                            # <  Multi Mode
MV_TRIGGER_MODE_ON = 1                           # <  On
AM_CycleDetect = 6                               # <  used internally for AccessMode cycle detection
AM_Undefined = 5                                 # <  Object is not yet initialized
AM_RW = 4                                        # <  Read and Write
AM_RO = 3                                        # <  Read Only
AM_WO = 2                                        # <  Write Only
AM_NA = 1                                        # <  Not available
AM_NI = 0                                        # <  Not implemented
MV_Image_Tif = 4                                 # <  Tif image file
MV_Image_Png = 3                                 # <  Png image file
MV_Image_Jpeg = 2                                # <  Jpeg image file
MV_Image_Bmp = 1                                 # <  Bmp image file
MV_GAIN_MODE_CONTINUOUS = 2                      # <  Gain Mode Continuous 
MV_GAIN_MODE_ONCE = 1                            # <  Gain Mode Once
MV_GrabStrategy_UpcomingImage = 3                # <  Wait for the next image
MV_GrabStrategy_LatestImages = 2                 # <  Gets the latest image in the list
MV_GrabStrategy_LatestImagesOnly = 1             # <  Gets the most recent image in the list (while clearing the rest of the images in the list)
MV_PointCloudFile_OBJ = 3                        # <  The point cloud format named OBJ
MV_PointCloudFile_CSV = 2                        # <  The point cloud format named CSV
MV_PointCloudFile_PLY = 1                        # <  The point cloud format named PLY
MV_ACQ_MODE_SINGLE = 0                           # <  Single Mode
MV_TRIGGER_MODE_OFF = 0                          # <  Off
MV_TRIGGER_SOURCE_SOFTWARE = 7                   # <  Trigger source software
MV_EXPOSURE_MODE_TIMED = 0                       # <  exposure mode timed
MV_FormatType_Undefined = 0                      # <  Undefined format type
MV_GAIN_MODE_OFF = 0                             # <  Gain mode off
MV_EXPOSURE_AUTO_MODE_CONTINUOUS = 2             # <  Exposure auto mode continuous
MV_EXPOSURE_AUTO_MODE_ONCE = 1                   # <  Exposure auto mode once
MV_EXPOSURE_AUTO_MODE_OFF = 0                    # <  Exposure auto mode off
IFT_IValue = 0                                   # <  IValue interface
MV_GrabStrategy_OneByOne = 0                     # <  Frame by frame from old to new
MV_FormatType_AVI = 1                            # <  AVI format type
MV_GAMMA_SELECTOR_USER = 1                       # <  This enumeration selects the type of gamma to apply
IFT_IString = 6                                  # <  IString interface
MV_BALANCEWHITE_AUTO_OFF = 0                     # <  Balance white auto off
MV_GAMMA_SELECTOR_SRGB = 2                       # <  This enumeration selects the type of gamma to apply
IFT_IPort = 11                                   # <  IPort interface
MV_BALANCEWHITE_AUTO_CONTINUOUS = 1              # <  Balance white auto continuous
IFT_IEnumEntry = 10                              # <  IEnumEntry interface
IFT_ICategory = 8                                # <  ICategory interface
IFT_IRegister = 7                                # <  IRegister interface
MV_Image_Undefined = 0                           # <  Image undefined
IFT_IFloat = 5                                   # <  IFloat interface
IFT_IEnumeration = 9                             # <  IEnumeration interface
IFT_ICommand = 4                                 # <  ICommand interface
IFT_IBoolean = 3                                 # <  IBoolean interface
IFT_IInteger = 2                                 # <  IInteger interface
MV_GIGE_TRANSTYPE_MULTICAST_WITHOUT_RECV = 65537 # <  Multicast without receive data
IFT_IBase = 1                                    # <  IBase interface
MV_GIGE_TRANSTYPE_UNICAST_WITHOUT_RECV = 65536   # <  Unicast without receive data
MV_BALANCEWHITE_AUTO_ONCE = 2                    # <  Balance white auto once
MV_GIGE_TRANSTYPE_LIMITEDBROADCAST = 2           # <  Limited broadcast mode,not support
MV_GIGE_TRANSTYPE_MULTICAST = 1                  # <  Multicast mode
MV_GIGE_TRANSTYPE_UNICAST = 0                    # <  Unicast mode(default)
MV_GIGE_TRANSTYPE_CAMERADEFINED = 4              # <  Transtype from camera,not support
MV_GIGE_TRANSTYPE_SUBNETBROADCAST = 3            # <  Subnet broadcast mode,not support
MV_EXPOSURE_MODE_TRIGGER_WIDTH = 1               # <  Trigger width
MV_GIGE_TRANSTYPE_UNICAST_DEFINED_PORT = 5       # <  User Defined Receive Data Port
MV_TRIGGER_SOURCE_FrequencyConverter = 8         # <  Trigger source frequency converter
MV_TRIGGER_SOURCE_COUNTER0 = 4                   # <  Trigger source conuter
MV_TRIGGER_SOURCE_LINE3 = 3                      # <  Trigger source line3
MV_TRIGGER_SOURCE_LINE2 = 2                      # <  Trigger source line2
MV_TRIGGER_SOURCE_LINE1 = 1                      # <  Trigger source line1
MV_TRIGGER_SOURCE_LINE0 = 0                      # <  Trigger source line0
SortMethod_SerialNumber = 0                      # <  Sorting by SerialNumber
SortMethod_UserID = 1                            # <  Sorting by UserID
SortMethod_CurrentIP_ASC = 2                     # <  Sorting by current IP（Ascending）
SortMethod_CurrentIP_DESC = 3                    # <  Sorting by current IP（Descending）
MV_IMAGE_ROTATE_90 = 1                           # <  Rotate 90 degrees
MV_IMAGE_ROTATE_180 = 2                          # <  Rotate 180 degrees
MV_IMAGE_ROTATE_270 = 3                          # <  Rotate 270 degrees
MV_FLIP_VERTICAL = 1                             # <  flip vertical
MV_FLIP_HORIZONTAL = 2                           # <  flip horizontal
MV_CC_GAMMA_TYPE_NONE = 0                        # <  Disable
MV_CC_GAMMA_TYPE_VALUE = 1                       # <  Gamma value
MV_CC_GAMMA_TYPE_USER_CURVE = 2                  # <  Gamma curve
MV_CC_GAMMA_TYPE_LRGB2SRGB = 3                   # <  linear RGB to sRGB
MV_CC_GAMMA_TYPE_SRGB2LRGB = 4                   # <  sRGB to linear RGB
MV_CC_STREAM_EXCEPTION_ABNORMAL_IMAGE = 0x4001   # <  abnormal image,the frame is discarded
MV_CC_STREAM_EXCEPTION_LIST_OVERFLOW = 0x4002    # <  Cache list overflow, clear the oldest frame
MV_CC_STREAM_EXCEPTION_LIST_EMPTY = 0x4003       # <  Cache list is empty,the frame is discarded
MV_CC_STREAM_EXCEPTION_RECONNECTION = 0x4004    # <  reconnect
MV_CC_STREAM_EXCEPTION_DISCONNECTED = 0x4005    # <  reconnect fail, stream is  terminated
MV_CC_STREAM_EXCEPTION_DEVICE = 0x4006          # <  device exception
MV_SPLIT_BY_LINE = 1                            #<  Source image split into multiple images by line
int8_t = c_int8
int16_t = c_int16
int32_t = c_int32
int64_t = c_int64
uint8_t = c_uint8
uint16_t = c_uint16
uint32_t = c_uint32
uint64_t = c_uint64
int_least8_t = c_byte
int_least16_t = c_short
int_least32_t = c_int
int_least64_t = c_long
uint_least8_t = c_ubyte
uint_least16_t = c_ushort
uint_least32_t = c_uint
uint_least64_t = c_ulong
int_fast8_t = c_byte
int_fast16_t = c_long
int_fast32_t = c_long
int_fast64_t = c_long
uint_fast8_t = c_ubyte
uint_fast16_t = c_ulong
uint_fast32_t = c_ulong
uint_fast64_t = c_ulong
intptr_t = c_long
uintptr_t = c_ulong
intmax_t = c_long
uintmax_t = c_ulong

# GigE device info
class _MV_GIGE_DEVICE_INFO_(Structure):
    pass
_MV_GIGE_DEVICE_INFO_._fields_ = [
    ('nIpCfgOption', c_uint),                     # <  Ip config option
    ('nIpCfgCurrent', c_uint),                    # <  IP configuration:bit31-static bit30-dhcp bit29-lla
    ('nCurrentIp', c_uint),                       # <  Current host Ip 
    ('nCurrentSubNetMask', c_uint),               # <  curtent subnet mask
    ('nDefultGateWay', c_uint),                   # <  Default gate way
    ('chManufacturerName', c_ubyte * 32),         # <  Manufacturer Name
    ('chModelName', c_ubyte * 32),                # <  Mode name
    ('chDeviceVersion', c_ubyte * 32),            # <  Device Version
    ('chManufacturerSpecificInfo', c_ubyte * 48), # <  Manufacturer Specific Infomation
    ('chSerialNumber', c_ubyte * 16),             # <  serial number
    ('chUserDefinedName', c_ubyte * 16),          # <  User Defined Name
    ('nNetExport', c_uint),                       # <  NetWork Ip address
    ('nReserved', c_uint * 4),                    # <  Reserved bytes
]
MV_GIGE_DEVICE_INFO = _MV_GIGE_DEVICE_INFO_

# USB device info
class _MV_USB3_DEVICE_INFO_(Structure):
    pass
_MV_USB3_DEVICE_INFO_._fields_ = [
    ('CrtlInEndPoint', c_ubyte),                            # <  Control input endpoint
    ('CrtlOutEndPoint', c_ubyte),                           # <  Control output endpoint
    ('StreamEndPoint', c_ubyte),                            # <  Flow endpoint
    ('EventEndPoint', c_ubyte),                             # <  Event endpoint
    ('idVendor', c_ushort),                                 # <  Vendor ID Number
    ('idProduct', c_ushort),                                # <  Device ID Number
    ('nDeviceNumber', c_uint),                              # <  Device Serial Number
    ('chDeviceGUID', c_ubyte * INFO_MAX_BUFFER_SIZE),       # <  Device GUID Number
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),       # <  Vendor Name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),        # <  Model Name
    ('chFamilyName', c_ubyte * INFO_MAX_BUFFER_SIZE),       # <  Family Name
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # <  Device Version
    ('chManufacturerName', c_ubyte * INFO_MAX_BUFFER_SIZE), # <  Manufacturer Name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # <  Serial Number
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # <  User Defined Name
    ('nbcdUSB', c_uint),                                    # <  Support USB Protocol
    ('nDeviceAddress', c_uint),                             # <  Device Address
    ('nReserved', c_uint * 2),                              # <  Reserved bytes
]
MV_USB3_DEVICE_INFO = _MV_USB3_DEVICE_INFO_

# CameraLink device info
class _MV_CamL_DEV_INFO_(Structure):
    pass
_MV_CamL_DEV_INFO_._fields_ = [
    ('chPortID', c_ubyte * INFO_MAX_BUFFER_SIZE),           # <  Port ID         
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),        # <  Model name
    ('chFamilyName', c_ubyte * INFO_MAX_BUFFER_SIZE),       # <  Family Name
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # <  Device Version
    ('chManufacturerName', c_ubyte * INFO_MAX_BUFFER_SIZE), # <  Manufacturer Name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # <  Serial Number
    ('nReserved', c_uint * 38),                             # <  Reserved bytes
]
MV_CamL_DEV_INFO = _MV_CamL_DEV_INFO_

# CameraParams.h 80
class _MV_CC_DEVICE_INFO_(Structure):
    pass
# Device info
class N19_MV_CC_DEVICE_INFO_3DOT_0E(Union):
    pass
N19_MV_CC_DEVICE_INFO_3DOT_0E._fields_ = [
    ('stGigEInfo', MV_GIGE_DEVICE_INFO),                   # <  Gige device infomation
    ('stUsb3VInfo', MV_USB3_DEVICE_INFO),                  # <  u3V device information
    ('stCamLInfo', MV_CamL_DEV_INFO),                      # <  CamLink device information
]

_MV_CC_DEVICE_INFO_._fields_ = [
    # CameraParams.h 80
    ('nMajorVer', c_ushort),                              # <  Major version of the specification.
    ('nMinorVer', c_ushort),                              # <  Minor version of the specification
    ('nMacAddrHigh', c_uint),                             # <  Mac address high
    ('nMacAddrLow', c_uint),                              # <  Mac address low
    ('nTLayerType', c_uint),                              # <  Device Transport Layer Protocol Type, e.g. MV_GIGE_DEVICE
    ('nReserved', c_uint * 4),                            # <  Reserved bytes
    ('SpecialInfo', N19_MV_CC_DEVICE_INFO_3DOT_0E),       # <  Special information
]
MV_CC_DEVICE_INFO = _MV_CC_DEVICE_INFO_

# Device Information List
class _MV_CC_DEVICE_INFO_LIST_(Structure):
    pass
_MV_CC_DEVICE_INFO_LIST_._fields_ = [
    ('nDeviceNum', c_uint),                                          # <  Online Device Number
    ('pDeviceInfo', POINTER(MV_CC_DEVICE_INFO) * MV_MAX_DEVICE_NUM), # <  Support up to 256 devices
]
MV_CC_DEVICE_INFO_LIST = _MV_CC_DEVICE_INFO_LIST_

# Interface Information with GenTL
class _MV_GENTL_IF_INFO_(Structure):
    pass
_MV_GENTL_IF_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE), # <  Interface ID of GenTL
    ('chTLType', c_ubyte * INFO_MAX_BUFFER_SIZE),      # <  Transport Layer type
    ('chDisplayName', c_ubyte * INFO_MAX_BUFFER_SIZE), # <  Display name
    ('nCtiIndex', c_uint),                             # <  Cti file index of GenTL 
    ('nReserved', c_uint * 8),                         # <  Reserved bytes
]
MV_GENTL_IF_INFO = _MV_GENTL_IF_INFO_

# Device Information List with GenTL
class _MV_GENTL_IF_INFO_LIST_(Structure):
    pass
_MV_GENTL_IF_INFO_LIST_._fields_ = [
    ('nInterfaceNum', c_uint),                                    # <  Online Device Number
    ('pIFInfo', POINTER(MV_GENTL_IF_INFO) * MV_MAX_GENTL_IF_NUM), # <  Support up to 256 devices
]
MV_GENTL_IF_INFO_LIST = _MV_GENTL_IF_INFO_LIST_

# Device Information with GenTL
class _MV_GENTL_DEV_INFO_(Structure):
    pass
_MV_GENTL_DEV_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),          # <  Interface ID of GenTL
    ('chDeviceID', c_ubyte * INFO_MAX_BUFFER_SIZE),             # <  Device ID
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),           # <  Vendor Name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),            # <  Model name
    ('chTLType', c_ubyte * INFO_MAX_BUFFER_SIZE),               # <  Transport Layer type
    ('chDisplayName', c_ubyte * INFO_MAX_BUFFER_SIZE),          # <  Display name
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),      # <  User defined name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),         # <  Serial number
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),        # <  Device version
    ('nCtiIndex', c_uint),                                      # <  Cti Index
    ('nReserved', c_uint * 8),                                  # <  Reserved bytes
]
MV_GENTL_DEV_INFO = _MV_GENTL_DEV_INFO_

# Device Information List with GenTL
class _MV_GENTL_DEV_INFO_LIST_(Structure):
    pass
_MV_GENTL_DEV_INFO_LIST_._fields_ = [
    ('nDeviceNum', c_uint),                                             # <  Online Device Number
    ('pDeviceInfo', POINTER(MV_GENTL_DEV_INFO) * MV_MAX_GENTL_DEV_NUM), # <  device infomation of GenTL device
]
MV_GENTL_DEV_INFO_LIST = _MV_GENTL_DEV_INFO_LIST_

# The content of ChunkData
class _MV_CHUNK_DATA_CONTENT_(Structure):
    pass
_MV_CHUNK_DATA_CONTENT_._fields_ = [
    ('pChunkData', POINTER(c_ubyte)),  # <  Chunk data
    ('nChunkID', c_uint),              # <  Chunk id
    ('nChunkLen', c_uint),             # <  Chunk len
    ('nReserved', c_uint * 8),         # <  Reserved bytes
]
MV_CHUNK_DATA_CONTENT = _MV_CHUNK_DATA_CONTENT_

# Output Frame Information
class _MV_FRAME_OUT_INFO_EX_(Structure):
    pass
# values for enumeration 'MvGvspPixelType'
MvGvspPixelType = c_int # enum

class N22_MV_FRAME_OUT_INFO_EX_3DOT_1E(Union):
    pass
N22_MV_FRAME_OUT_INFO_EX_3DOT_1E._fields_ = [
    ('pUnparsedChunkContent', POINTER(MV_CHUNK_DATA_CONTENT)), # <  Chunk Content
    ('nAligning', int64_t),                                    # <  Aligning
]
_MV_FRAME_OUT_INFO_EX_._fields_ = [
    ('nWidth', c_ushort),
    # <  Image Width (over 65535, use nExtendWidth)
    ('nHeight', c_ushort),
    # <  Image Height(over 65535, use nExtendHeight)
    ('enPixelType', MvGvspPixelType),                        # <  Pixel Type
    ('nFrameNum', c_uint),                                   # < Frame Number
    ('nDevTimeStampHigh', c_uint),                           # < Timestamp high 32 bits
    ('nDevTimeStampLow', c_uint),                            # < Timestamp low 32 bits
    ('nReserved0', c_uint),                                  # < Reserved, 8-byte aligned
    ('nHostTimeStamp', int64_t),                             # < Host-generated timestamp
    ('nFrameLen', c_uint),                                   # < Frame length
    # < The followings are chunk add frame-specific information
    # < Device frame-specific time scale
    ('nSecondCount', c_uint),                                
    ('nCycleCount', c_uint),                                 
    ('nCycleOffset', c_uint),                                
    ('fGain', c_float),                                      # < Gain
    ('fExposureTime', c_float),                              # < Exposure Time
    ('nAverageBrightness', c_uint),                          # < Average brightness
    # < White balance
    ('nRed', c_uint),                                         
    ('nGreen', c_uint),                                      
    ('nBlue', c_uint),                                       
    ('nFrameCounter', c_uint),                               # < Frame counter
    ('nTriggerIndex', c_uint),                               # < Trigger index
    # < Line Input/Output
    ('nInput', c_uint),                                     
    ('nOutput', c_uint),             
    # < ROI Region                       
    ('nOffsetX', c_ushort),                                  
    ('nOffsetY', c_ushort),                                  
    ('nChunkWidth', c_ushort),                              
    ('nChunkHeight', c_ushort),                             
    ('nLostPacket', c_uint),                                 # < Lost Pacekt Number In This Frame
    ('nUnparsedChunkNum', c_uint),                           # < Unparsed chunk number
    ('UnparsedChunkList', N22_MV_FRAME_OUT_INFO_EX_3DOT_1E), # < Unparsed chunk list
    ('nExtendWidth', c_uint),                                # < Image Width
    ('nExtendHeight', c_uint),                               # < Image Height
    ('nReserved', c_uint * 34),                              # < Reserved bytes
]
MV_FRAME_OUT_INFO_EX = _MV_FRAME_OUT_INFO_EX_

# Display frame information
class _MV_DISPLAY_FRAME_INFO_EX_(Structure):
    pass
_MV_DISPLAY_FRAME_INFO_EX_._fields_ = [
    ('nWidth', c_uint),                # < Image Width
    ('nHeight', c_uint),               # < Image Height
    ('enPixelType', MvGvspPixelType),  # < Pixel Type
    ('pImageBuf', POINTER(c_ubyte)),   # < Input image buffer
    ('nImageBufLen', c_uint),          # < Input image length
    ('nRes', c_uint * 4),              # < Reserved bytes
]
MV_DISPLAY_FRAME_INFO_EX = _MV_DISPLAY_FRAME_INFO_EX_

# Image Struct, output the pointer of Image and the information of the specific image
class _MV_FRAME_OUT_(Structure):
    pass
_MV_FRAME_OUT_._fields_ = [
    ('pBufAddr', POINTER(c_ubyte)),         # < pointer of image
    ('stFrameInfo', MV_FRAME_OUT_INFO_EX),  # < information of the specific image
    ('nRes', c_uint * 16),                  # < Reserved bytes
]
MV_FRAME_OUT = _MV_FRAME_OUT_

# values for enumeration '_MV_GRAB_STRATEGY_'
_MV_GRAB_STRATEGY_ = c_int # enum       
MV_GRAB_STRATEGY = _MV_GRAB_STRATEGY_   

# Network transmission information
class _MV_NETTRANS_INFO_(Structure):
    pass
_MV_NETTRANS_INFO_._fields_ = [
    ('nReceiveDataSize', int64_t),          # < Received Data Size  [Calculate the Data Size between StartGrabbing and StopGrabbing]  
    ('nThrowFrameCount', c_int),            # < Throw frame number
    ('nNetRecvFrameCount', c_uint),         # < Receive Frame count
    ('nRequestResendPacketCount', int64_t), # < Request Resend Packet Count
    ('nResendPacketCount', int64_t),        # < Resend Packet Count
]
MV_NETTRANS_INFO = _MV_NETTRANS_INFO_

# A fully matched information structure
class _MV_ALL_MATCH_INFO_(Structure):
    pass
_MV_ALL_MATCH_INFO_._fields_ = [
    ('nType', c_uint),              # < Information type need to output
    ('pInfo', c_void_p),            # < Output information cache, which is allocated by the caller
    ('nInfoSize', c_uint),          # < Information cache size
]
MV_ALL_MATCH_INFO = _MV_ALL_MATCH_INFO_

# MV_MATCH_TYPE_NET_DETECT    Network traffic and packet loss feedback structure, the corresponding type is MV_MATCH_TYPE_NET_DETECT
class _MV_MATCH_INFO_NET_DETECT_(Structure):
    pass
_MV_MATCH_INFO_NET_DETECT_._fields_ = [
    ('nReceiveDataSize', int64_t),          # < Received data size
    ('nLostPacketCount', int64_t),          # < Number of packets lost
    ('nLostFrameCount', c_uint),            # < Number of frames lost
    ('nNetRecvFrameCount', c_uint),         # < Receive Frame count
    ('nRequestResendPacketCount', int64_t), # < Request Resend Packet Count
    ('nResendPacketCount', int64_t),        # < Resend Packet Count
]
MV_MATCH_INFO_NET_DETECT = _MV_MATCH_INFO_NET_DETECT_

# The total number of bytes host received from the u3v device side, the corresponding type is MV_MATCH_TYPE_USB_DETECT
class _MV_MATCH_INFO_USB_DETECT_(Structure):
    pass
_MV_MATCH_INFO_USB_DETECT_._fields_ = [
    ('nReceiveDataSize', int64_t),   # < Received data size
    ('nReceivedFrameCount', c_uint), # < Number of frames received
    ('nErrorFrameCount', c_uint),    # < Number of error frames
    ('nReserved', c_uint * 2),       # < Reserved bytes
]
MV_MATCH_INFO_USB_DETECT = _MV_MATCH_INFO_USB_DETECT_

# Display frame information
class _MV_DISPLAY_FRAME_INFO_(Structure):
    pass
_MV_DISPLAY_FRAME_INFO_._fields_ = [
    ('hWnd', c_void_p),               # < Windows handle
    ('pData', POINTER(c_ubyte)),      # < Data Buffer
    ('nDataLen', c_uint),             # < Data Size
    ('nWidth', c_ushort),             # < Width
    ('nHeight', c_ushort),            # < Height
    ('enPixelType', MvGvspPixelType), # < Pixel format
    ('nRes', c_uint * 4),             # < Reserved bytes
]
MV_DISPLAY_FRAME_INFO = _MV_DISPLAY_FRAME_INFO_

# values for enumeration 'MV_SAVE_POINT_CLOUD_FILE_TYPE'
MV_SAVE_POINT_CLOUD_FILE_TYPE = c_int # enum

# Save 3D data to buffer
class _MV_SAVE_POINT_CLOUD_PARAM_(Structure):
    pass
_MV_SAVE_POINT_CLOUD_PARAM_._fields_ = [
    ('nLinePntNum', c_uint),                                 # < The number of points in each row,which is the width of the image
    ('nLineNum', c_uint),                                    # < The number of rows,which is the height of the image
    ('enSrcPixelType', MvGvspPixelType),                     # < The pixel format of the input data
    ('pSrcData', POINTER(c_ubyte)),                          # < Input data buffer
    ('nSrcDataLen', c_uint),                                 # < Input data size
    ('pDstBuf', POINTER(c_ubyte)),                           # < Output pixel data buffer
    ('nDstBufSize', c_uint),                                 # < Output buffer size provided (nLinePntNum * nLineNum * (16*3 + 4) + 2048) 
    ('nDstBufLen', c_uint),                                  # < Output pixel data buffer size
    ('enPointCloudFileType', MV_SAVE_POINT_CLOUD_FILE_TYPE), # < Output point data file type provided
    ('nReserved', c_uint * 8),                               # < Reserved bytes
]
MV_SAVE_POINT_CLOUD_PARAM = _MV_SAVE_POINT_CLOUD_PARAM_

# values for enumeration 'MV_SAVE_IAMGE_TYPE'
MV_SAVE_IAMGE_TYPE = c_int # enum

# Save Image Parameters
class _MV_SAVE_IMAGE_PARAM_T_EX_(Structure):
    pass
_MV_SAVE_IMAGE_PARAM_T_EX_._fields_ = [
    ('pData', POINTER(c_ubyte)),                            # < Input Data Buffer
    ('nDataLen', c_uint),                                   # < Input Data Size
    ('enPixelType', MvGvspPixelType),                       # < Input Data Pixel Format
    ('nWidth', c_ushort),                                   # < Image Width
    ('nHeight', c_ushort),                                  # < Image Height
    ('pImageBuffer', POINTER(c_ubyte)),                     # < Output Image Buffer
    ('nImageLen', c_uint),                                  # < Output Image Size
    ('nBufferSize', c_uint),                                # < Output buffer size provided
    ('enImageType', MV_SAVE_IAMGE_TYPE),                    # < Output Image Format
    ('nJpgQuality', c_uint),                                # < Encoding quality, (50-99]
	# < Interpolation method of convert Bayer to RGB24  0-nearest neighbour 1-bilinearity 2-Hamilton
    ('iMethodValue', c_uint),
    ('nReserved', c_uint * 3),                              # < Reserved bytes
]
MV_SAVE_IMAGE_PARAM_EX = _MV_SAVE_IMAGE_PARAM_T_EX_

class _MV_SAVE_IMAGE_PARAM_EX3_(Structure):
    pass
_MV_SAVE_IMAGE_PARAM_EX3_._fields_ = [
    ('pData', POINTER(c_ubyte)),                            # < Input Data Buffer
    ('nDataLen', c_uint),                                   # < Input Data Size
    ('enPixelType', MvGvspPixelType),                       # < Input Data Pixel Format
    ('nWidth', c_uint),                                   # < Image Width
    ('nHeight', c_uint),                                  # < Image Height
    ('pImageBuffer', POINTER(c_ubyte)),                     # < Output Image Buffer
    ('nImageLen', c_uint),                                  # < Output Image Size
    ('nBufferSize', c_uint),                                # < Output buffer size provided
    ('enImageType', MV_SAVE_IAMGE_TYPE),                    # < Output Image Format
    ('nJpgQuality', c_uint),                                # < Encoding quality, (50-99]
	# < Interpolation method of convert Bayer to RGB24  0-nearest neighbour 1-bilinearity 2-Hamilton
    ('iMethodValue', c_uint),
    ('nReserved', c_uint * 3),                              # < Reserved bytes
]
MV_SAVE_IMAGE_PARAM_EX3 = _MV_SAVE_IMAGE_PARAM_EX3_

# Save BMP、JPEG、PNG、TIFF image file parameters
class _MV_SAVE_IMG_TO_FILE_PARAM_(Structure):
    pass
_MV_SAVE_IMG_TO_FILE_PARAM_._fields_ = [
    ('enPixelType', MvGvspPixelType),    # < The pixel format of the input data
    ('pData', POINTER(c_ubyte)),         # < Input Data Buffer
    ('nDataLen', c_uint),                # < Input Data Size
    ('nWidth', c_ushort),                # < Image Width
    ('nHeight', c_ushort),               # < Image Height
    ('enImageType', MV_SAVE_IAMGE_TYPE), # < Input Image Format
    ('nQuality', c_uint),                # < JPG Encoding quality(50-99],PNG Encoding quality[0-9]
    ('pImagePath', c_char * 256),        # < Input file path
    # <   en:Interpolation method of convert Bayer to RGB24  0-nearest neighbour 1-bilinearity 2-Hamilton
    ('iMethodValue', c_int),             
    ('nReserved', c_uint * 8),           # < Reserved bytes
]
MV_SAVE_IMG_TO_FILE_PARAM = _MV_SAVE_IMG_TO_FILE_PARAM_

class _MV_SAVE_IMAGE_TO_FILE_PARAM_EX_(Structure):
    pass
_MV_SAVE_IMAGE_TO_FILE_PARAM_EX_._fields_ = [
    ('nWidth', c_uint),  # < Image Width
    ('nHeight', c_uint),  # < Image Height
    ('enPixelType', MvGvspPixelType),
    # < The pixel format of the input data
    ('pData', POINTER(c_ubyte)),  # < Input Data Buffer
    ('nDataLen', c_uint),  # < Input Data Size

    ('enImageType', MV_SAVE_IAMGE_TYPE),
    # < Input Image Format
    ('pcImagePath', POINTER(c_char)),  # < Input file path
    ('nQuality', c_uint),
    # <  JPG Encoding quality(50-99],PNG Encoding quality[0-9]
    # <   en:Interpolation method of convert Bayer to RGB24  0-nearest neighbour 1-bilinearity 2-Hamilton
    ('iMethodValue', c_int),
    ('nReserved', c_uint * 8),  # <  Reserved bytes
]
MV_SAVE_IMAGE_TO_FILE_PARAM_EX = _MV_SAVE_IMAGE_TO_FILE_PARAM_EX_

# \ Pixel convert structure
class _MV_CC_PIXEL_CONVERT_PARAM_T_(Structure):
    pass
_MV_CC_PIXEL_CONVERT_PARAM_T_._fields_ = [
    ('nWidth', c_ushort),                # <  Image Width
    ('nHeight', c_ushort),               # <  Image Height
    ('enSrcPixelType', MvGvspPixelType), # <  Source pixel format
    ('pSrcData', POINTER(c_ubyte)),      # <  Input data buffer
    ('nSrcDataLen', c_uint),             # <  Input data size
    ('enDstPixelType', MvGvspPixelType), # <  Destination pixel format
    ('pDstBuffer', POINTER(c_ubyte)),    # <  Output data buffer
    ('nDstLen', c_uint),                 # <  Output data size
    ('nDstBufferSize', c_uint),          # <  Provided outbut buffer size
    ('nRes', c_uint * 4),                # <  Reserved bytes
]
MV_CC_PIXEL_CONVERT_PARAM = _MV_CC_PIXEL_CONVERT_PARAM_T_

class _MV_PIXEL_CONVERT_PARAM_EX_T_(Structure):
    pass
_MV_PIXEL_CONVERT_PARAM_EX_T_._fields_ = [
    ('nWidth', c_uint),                # <  Image Width
    ('nHeight', c_uint),               # <  Image Height
    ('enSrcPixelType', MvGvspPixelType), # <  Source pixel format
    ('pSrcData', POINTER(c_ubyte)),      # <  Input data buffer
    ('nSrcDataLen', c_uint),             # <  Input data size
    ('enDstPixelType', MvGvspPixelType), # <  Destination pixel format
    ('pDstBuffer', POINTER(c_ubyte)),    # <  Output data buffer
    ('nDstLen', c_uint),                 # <  Output data size
    ('nDstBufferSize', c_uint),          # <  Provided outbut buffer size
    ('nRes', c_uint * 4),                # <  Reserved bytes
]
MV_CC_PIXEL_CONVERT_PARAM_EX = _MV_PIXEL_CONVERT_PARAM_EX_T_

# values for enumeration '_MV_RECORD_FORMAT_TYPE_'
_MV_RECORD_FORMAT_TYPE_ = c_int # enum
MV_RECORD_FORMAT_TYPE = _MV_RECORD_FORMAT_TYPE_

#  Record Parameters
class _MV_CC_RECORD_PARAM_T_(Structure):
    pass
_MV_CC_RECORD_PARAM_T_._fields_ = [
    ('enPixelType', MvGvspPixelType),           # <  Ip config option
    ('nWidth', c_ushort),                       # <  Ip config option
    ('nHeight', c_ushort),                      # <  Ip config option
    ('fFrameRate', c_float),                    # <  Ip config option
    ('nBitRate', c_uint),                       # <  Ip config option
    ('enRecordFmtType', MV_RECORD_FORMAT_TYPE), # <  Ip config option
    ('strFilePath', STRING),                    # <  Video file storage path (if there is Chinese in the path, it needs to be converted to utf-8)
    ('nRes', c_uint * 8),                       # <  Reserved bytes
]
MV_CC_RECORD_PARAM = _MV_CC_RECORD_PARAM_T_

#  Record Data
class _MV_CC_INPUT_FRAME_INFO_T_(Structure):
    pass
_MV_CC_INPUT_FRAME_INFO_T_._fields_ = [
    ('pData', POINTER(c_ubyte)),  # <  Input Data Buffer
    ('nDataLen', c_uint),         # <  Input Data Size
    ('nRes', c_uint * 8),         # <  Reserved bytes
]
MV_CC_INPUT_FRAME_INFO = _MV_CC_INPUT_FRAME_INFO_T_

# values for enumeration '_MV_CAM_ACQUISITION_MODE_'
_MV_CAM_ACQUISITION_MODE_ = c_int # enum
MV_CAM_ACQUISITION_MODE = _MV_CAM_ACQUISITION_MODE_

# values for enumeration '_MV_CAM_GAIN_MODE_'
_MV_CAM_GAIN_MODE_ = c_int # enum
MV_CAM_GAIN_MODE = _MV_CAM_GAIN_MODE_

# values for enumeration '_MV_CAM_EXPOSURE_MODE_'
_MV_CAM_EXPOSURE_MODE_ = c_int # enum
MV_CAM_EXPOSURE_MODE = _MV_CAM_EXPOSURE_MODE_

# values for enumeration '_MV_CAM_EXPOSURE_AUTO_MODE_'
_MV_CAM_EXPOSURE_AUTO_MODE_ = c_int # enum
MV_CAM_EXPOSURE_AUTO_MODE = _MV_CAM_EXPOSURE_AUTO_MODE_

# values for enumeration '_MV_CAM_TRIGGER_MODE_'
_MV_CAM_TRIGGER_MODE_ = c_int # enum
MV_CAM_TRIGGER_MODE = _MV_CAM_TRIGGER_MODE_

# values for enumeration '_MV_CAM_GAMMA_SELECTOR_'
_MV_CAM_GAMMA_SELECTOR_ = c_int # enum
MV_CAM_GAMMA_SELECTOR = _MV_CAM_GAMMA_SELECTOR_

# values for enumeration '_MV_CAM_BALANCEWHITE_AUTO_'
_MV_CAM_BALANCEWHITE_AUTO_ = c_int # enum
MV_CAM_BALANCEWHITE_AUTO = _MV_CAM_BALANCEWHITE_AUTO_

# values for enumeration '_MV_CAM_TRIGGER_SOURCE_'
_MV_CAM_TRIGGER_SOURCE_ = c_int # enum
MV_CAM_TRIGGER_SOURCE = _MV_CAM_TRIGGER_SOURCE_

#  Event callback infomation
class _MV_EVENT_OUT_INFO_(Structure):
    pass
_MV_EVENT_OUT_INFO_._fields_ = [
    ('EventName', c_char * MAX_EVENT_NAME_SIZE), # <  Event name
    ('nEventID', c_ushort),                      # <  Event ID
    ('nStreamChannel', c_ushort),                # <  Circulation number
    ('nBlockIdHigh', c_uint),                    # <  BlockId high
    ('nBlockIdLow', c_uint),                     # <  BlockId low
    ('nTimestampHigh', c_uint),                  # <  Timestramp high
    ('nTimestampLow', c_uint),                   # <  Timestramp low
    ('pEventData', c_void_p),                    # <  Event data
    ('nEventDataSize', c_uint),                  # <  Event data len
    ('nReserved', c_uint * 16),                  # <  Reserved bytes
]
MV_EVENT_OUT_INFO = _MV_EVENT_OUT_INFO_

#  File Access
class _MV_CC_FILE_ACCESS_T(Structure):
    pass
_MV_CC_FILE_ACCESS_T._fields_ = [
    ('pUserFileName', STRING),  # <  User file name
    ('pDevFileName', STRING),   # <  Device file name
    ('nReserved', c_uint * 32), # <  Reserved bytes
]
MV_CC_FILE_ACCESS = _MV_CC_FILE_ACCESS_T

#  File Access Progress
class _MV_CC_FILE_ACCESS_PROGRESS_T(Structure):
    pass
_MV_CC_FILE_ACCESS_PROGRESS_T._fields_ = [
    ('nCompleted', int64_t),     # <  Completed Length
    ('nTotal', int64_t),         # <  Total Length
    ('nReserved', c_uint * 8),   # <  Reserved bytes
]
MV_CC_FILE_ACCESS_PROGRESS = _MV_CC_FILE_ACCESS_PROGRESS_T

# values for enumeration '_MV_GIGE_TRANSMISSION_TYPE_'
_MV_GIGE_TRANSMISSION_TYPE_ = c_int # enum
MV_GIGE_TRANSMISSION_TYPE = _MV_GIGE_TRANSMISSION_TYPE_

# 传输模式，可以为单播模式、组播模式等    Transmission type
class _MV_TRANSMISSION_TYPE_T(Structure):
    pass
_MV_TRANSMISSION_TYPE_T._fields_ = [
    ('enTransmissionType', MV_GIGE_TRANSMISSION_TYPE),  # <  Transmission type
    ('nDestIp', c_uint),                                # <  Destination IP
    ('nDestPort', c_ushort),                            # <  Destination port
    ('nReserved', c_uint * 32),                         # <  Reserved bytes
]
MV_TRANSMISSION_TYPE = _MV_TRANSMISSION_TYPE_T

#  Action Command
class _MV_ACTION_CMD_INFO_T(Structure):
    pass
_MV_ACTION_CMD_INFO_T._fields_ = [
    ('nDeviceKey', c_uint),        # <  Device key
    ('nGroupKey', c_uint),         # <  Group key
    ('nGroupMask', c_uint),        # <  Group mask
    ('bActionTimeEnable', c_uint), # <  Action time enable
    ('nActionTime', int64_t),      # <  Action time
    ('pBroadcastAddress', STRING), # <  Broadcast address
    ('nTimeOut', c_uint),          # <  Timeout
    ('nReserved', c_uint * 16),    # <  Reserved bytes
]
MV_ACTION_CMD_INFO = _MV_ACTION_CMD_INFO_T

#  Action Command Result
class _MV_ACTION_CMD_RESULT_T(Structure):
    pass
_MV_ACTION_CMD_RESULT_T._fields_ = [
    ('strDeviceAddress', c_ubyte * 16), # <  IP address of the device
    #1.0x0000:success.
    #2.0x8001:Command is not supported by the device.
    #3.0x8013:The device is not synchronized to a master clock to be used as time reference.
    #4.0x8015:A device queue or packet data has overflowed.
    #5.0x8016:The requested scheduled action command was requested at a time that is already past.
    ('nStatus', c_int),                 # <  status
    ('nReserved', c_uint * 4),          # <  Reserved bytes
]
MV_ACTION_CMD_RESULT = _MV_ACTION_CMD_RESULT_T

#  Action Command Result List
class _MV_ACTION_CMD_RESULT_LIST_T(Structure):
    pass
_MV_ACTION_CMD_RESULT_LIST_T._fields_ = [
    ('nNumResults', c_uint),                     # <  Num Results
    ('pResults', POINTER(MV_ACTION_CMD_RESULT)), # <  action command result list
]
MV_ACTION_CMD_RESULT_LIST = _MV_ACTION_CMD_RESULT_LIST_T

# values for enumeration 'MV_XML_InterfaceType'
MV_XML_InterfaceType = c_int # enum

# values for enumeration 'MV_XML_AccessMode'
MV_XML_AccessMode = c_int # enum

#  Enumeration Value
class _MVCC_ENUMVALUE_T(Structure):
    pass
_MVCC_ENUMVALUE_T._fields_ = [
    ('nCurValue', c_uint),                               # <  Current Value
    ('nSupportedNum', c_uint),                           # <  Number of valid data
    ('nSupportValue', c_uint * MV_MAX_XML_SYMBOLIC_NUM), # <  Support value list
    ('nReserved', c_uint * 4),                           # <  Reserved bytes
]
MVCC_ENUMVALUE = _MVCC_ENUMVALUE_T

#  Int Value
class _MVCC_INTVALUE_T(Structure):
    pass
_MVCC_INTVALUE_T._fields_ = [
    ('nCurValue', c_uint),     # <  Current Value
    ('nMax', c_uint),          # <  Max Value
    ('nMin', c_uint),          # <  Min Value
    ('nInc', c_uint),          # <  Step size
    ('nReserved', c_uint * 4), # <  Reserved bytes
]
MVCC_INTVALUE = _MVCC_INTVALUE_T

#  Int Value Ex
class _MVCC_INTVALUE_EX_T(Structure):
    pass
_MVCC_INTVALUE_EX_T._fields_ = [
    ('nCurValue', int64_t),     # <  Current Value
    ('nMax', int64_t),          # <  Max Value
    ('nMin', int64_t),          # <  Min Value
    ('nInc', int64_t),          # <  Step size
    ('nReserved', c_uint * 16), # <  Reserved bytes
]
MVCC_INTVALUE_EX = _MVCC_INTVALUE_EX_T

#  Float Value
class _MVCC_FLOATVALUE_T(Structure):
    pass
_MVCC_FLOATVALUE_T._fields_ = [
    ('fCurValue', c_float),    # <  Current Value
    ('fMax', c_float),         # <  Max Value
    ('fMin', c_float),         # <  Min Value
    ('nReserved', c_uint * 4), # <  Reserved bytes
]
MVCC_FLOATVALUE = _MVCC_FLOATVALUE_T

#  String Value
class _MVCC_STRINGVALUE_T(Structure):
    pass
_MVCC_STRINGVALUE_T._fields_ = [
    ('chCurValue', c_char * 256), # <  Current Value
    ('nMaxLength', int64_t),      # <  Max length
    ('nReserved', c_uint * 2),    # <  Reserved bytes
]
MVCC_STRINGVALUE = _MVCC_STRINGVALUE_T

#   Frame-specific information
class _MV_CC_FRAME_SPEC_INFO_(Structure):
    pass
_MV_CC_FRAME_SPEC_INFO_._fields_ = [
    # <  Device frame-specific time scale
    ('nSecondCount', c_uint),        # <  The Seconds
    ('nCycleCount', c_uint),         # <  The Count of Cycle
    ('nCycleOffset', c_uint),        # <  The Offset of Cycle
    ('fGain', c_float),              # <  Gain
    ('fExposureTime', c_float),      # <  Exposure Time
    ('nAverageBrightness', c_uint),  # <  Average brightness
    # <  White balance
    ('nRed', c_uint),    # <  Red
    ('nGreen', c_uint),  # <  Green
    ('nBlue', c_uint),   # <  Blue
    ('nFrameCounter', c_uint),  # <  Frame Counter
    ('nTriggerIndex', c_uint),  # <  Trigger Counting
    ('nInput', c_uint),  # <  Input
    ('nOutput', c_uint), # <  Output
    # <  ROI Region
    ('nOffsetX', c_ushort),      # <  OffsetX
    ('nOffsetY', c_ushort),      # <  OffsetY
    ('nFrameWidth', c_ushort),   # <  The Width of Chunk
    ('nFrameHeight', c_ushort),  # <  The Height of Chunk
    ('nReserved', c_uint * 16),   # <  Reserved bytes
]
MV_CC_FRAME_SPEC_INFO = _MV_CC_FRAME_SPEC_INFO_

#  High Bandwidth decode structure
class _MV_CC_HB_DECODE_PARAM_T_(Structure):
    pass
_MV_CC_HB_DECODE_PARAM_T_._fields_ = [
    ('pSrcBuf', POINTER(c_ubyte)),      # <  Input data buffer
    ('nSrcLen', c_uint),                # <  Input data size
    ('nWidth', c_uint),                 # <  Image Width
    ('nHeight', c_uint),                # <  Image Height
    ('pDstBuf', POINTER(c_ubyte)),      # <  Output data buffer
    ('nDstBufSize', c_uint),            # <  Provided output buffer size
    ('nDstBufLen', c_uint),             # <  Output data size
    ('enDstPixelType', MvGvspPixelType),  # <  Output pixel format
    ('stFrameInfo', MV_CC_FRAME_SPEC_INFO),  # <  Frame Spec Info
    ('nRes', c_uint * 8),                 # <  Reserved bytes
]
MV_CC_HB_DECODE_PARAM = _MV_CC_HB_DECODE_PARAM_T_

# values for enumeration '_MV_SORT_METHOD_'
_MV_SORT_METHOD_ = c_int  # enum
MV_SORT_METHOD = _MV_SORT_METHOD_

# values for enumeration '_MV_IMG_ROTATION_ANGLE_'
_MV_IMG_ROTATION_ANGLE_ = c_int  # enum
MV_IMG_ROTATION_ANGLE = _MV_IMG_ROTATION_ANGLE_

# values for enumeration '_MV_IMG_FLIP_TYPE_'
_MV_IMG_FLIP_TYPE_ = c_int  # enum
MV_IMG_FLIP_TYPE = _MV_IMG_FLIP_TYPE_

# values for enumeration '_MV_CC_GAMMA_TYPE_'
_MV_CC_GAMMA_TYPE_ = c_int  # enum
MV_CC_GAMMA_TYPE = _MV_CC_GAMMA_TYPE_

# values for enumeration '_MV_CC_STREAM_EXCEPTION_TYPE_'
_MV_CC_STREAM_EXCEPTION_TYPE_ = c_int  # enum
MV_CC_STREAM_EXCEPTION_TYPE = _MV_CC_STREAM_EXCEPTION_TYPE_

# values for enumeration '_MV_IMAGE_RECONSTRUCTION_METHOD_'
_MV_IMAGE_RECONSTRUCTION_METHOD_ = c_int  # enum
MV_IMAGE_RECONSTRUCTION_METHOD = _MV_IMAGE_RECONSTRUCTION_METHOD_

#  Rotate image structure
class _MV_CC_ROTATE_IMAGE_PARAM_T_(Structure):
    pass
_MV_CC_ROTATE_IMAGE_PARAM_T_._fields_ = [
    ('enPixelType', MvGvspPixelType),   # <  pixel format
    ('nWidth', c_uint),                 # <  Image Width
    ('nHeight', c_uint),                # <  Image Height
    ('pSrcData', POINTER(c_ubyte)),     # <  Input data buffer
    ('nSrcDataLen', c_uint),            # <  Input data length
    ('pDstBuf', POINTER(c_ubyte)),      # <  Output data buffer
    ('nDstBufLen', c_uint),             # <  Output data length
    ('nDstBufSize', c_uint),            # <  Provided output buffer size
    ('enRotationAngle', MV_IMG_ROTATION_ANGLE),   # <  Rotation angle
    ('nRes', c_uint * 8),               # <  Reserved bytes
]
MV_CC_ROTATE_IMAGE_PARAM = _MV_CC_ROTATE_IMAGE_PARAM_T_

#  Flip image structure
class _MV_CC_FLIP_IMAGE_PARAM_T_(Structure):
    pass
_MV_CC_FLIP_IMAGE_PARAM_T_._fields_ = [
    ('enPixelType', MvGvspPixelType),   # <  pixel format
    ('nWidth', c_uint),                 # <  Image Width
    ('nHeight', c_uint),                # <  Image Height
    ('pSrcData', POINTER(c_ubyte)),     # <  Input data buffer
    ('nSrcDataLen', c_uint),            # <  Input data length
    ('pDstBuf', POINTER(c_ubyte)),      # <  Output data buffer
    ('nDstBufLen', c_uint),             # <  Output data length
    ('nDstBufSize', c_uint),            # <  Provided output buffer size
    ('enFlipType', MV_IMG_FLIP_TYPE),   # <  Flip type
    ('nRes', c_uint * 8),               # <  Reserved bytes
]
MV_CC_FLIP_IMAGE_PARAM = _MV_CC_FLIP_IMAGE_PARAM_T_

#  Gamma info structure
class _MV_CC_GAMMA_PARAM_T_(Structure):
    pass
_MV_CC_GAMMA_PARAM_T_._fields_ = [
    ('enGammaType', MV_CC_GAMMA_TYPE),       # <  Gamma type
    ('fGammaValue', c_float),                # <  Gamma value[0.1,4.0]
    ('pGammaCurveBuf', POINTER(c_ubyte)),    # <  Gamma curve buffer
    ('nGammaCurveBufLen', c_uint),           # <  Gamma curve buffer size
    ('nRes', c_uint * 8),                    # <  Reserved bytes
]
MV_CC_GAMMA_PARAM = _MV_CC_GAMMA_PARAM_T_

#  CCM param
class _MV_CC_CCM_PARAM_T_(Structure):
    pass
_MV_CC_CCM_PARAM_T_._fields_ = [
    ('bCCMEnable', c_bool),         # <  CCM enable
    ('nCCMat', c_int * 9),          # <  Color correction matrix(-8192~8192)
    ('nRes', c_uint * 8),           # <  Reserved bytes
]
MV_CC_CCM_PARAM = _MV_CC_CCM_PARAM_T_

#  CCM param
class _MV_CC_CCM_PARAM_EX_T_(Structure):
    pass
_MV_CC_CCM_PARAM_EX_T_._fields_ = [
    ('bCCMEnable', c_bool),         # <  CCM enable
    ('nCCMat', c_int * 9),          # <  Color correction matrix(-65536~65536)
    ('nCCMScale', c_uint),
    # <  Quantitative scale(Integer power of 2, <= 65536)
    ('nRes', c_uint * 8),           # <  Reserved bytes
]
MV_CC_CCM_PARAM_EX = _MV_CC_CCM_PARAM_EX_T_

#  Contrast structure
class _MV_CC_CONTRAST_PARAM_T_(Structure):
    pass
_MV_CC_CONTRAST_PARAM_T_._fields_ = [
    ('nWidth', c_uint),                 # <  Image Width
    ('nHeight', c_uint),                # <  Image Height
    ('pSrcBuf', POINTER(c_ubyte)),      # <  Input data buffer
    ('nSrcBufLen', c_uint),             # <  Input data length
    ('enPixelType', MvGvspPixelType),   # <  pixel format
    ('pDstBuf', POINTER(c_ubyte)),      # <  Output data buffer
    ('nDstBufSize', c_uint),            # <  Provided output buffer size
    ('nDstBufLen', c_uint),            # <  Output data length
    ('nContrastFactor', c_uint),       # <  Contrast factor,[1,10000]
    ('nRes', c_uint * 8),                 # <  Reserved bytes
]
MV_CC_CONTRAST_PARAM_T = _MV_CC_CONTRAST_PARAM_T_

#  Enumeration Entry
class _MVCC_ENUMENTRY_T(Structure):
    pass
_MVCC_ENUMENTRY_T._fields_ = [
    ('nValue', c_uint),                             # <  Value
    ('chSymbolic', c_char * MV_MAX_SYMBOLIC_LEN),  # <  Symbolic

    ('nReserved', c_uint * 4),                      # <  Reserved bytes
]
MVCC_ENUMENTRY = _MVCC_ENUMENTRY_T

#  Color of Auxiliary Line
class _MVCC_COLORF(Structure):
    pass
_MVCC_COLORF._fields_ = [
    ('fR', c_float),
    # <  Red，Range[0.0, 1.0]
    ('fG', c_float),
    # <  Green，Range[0.0, 1.0]
    ('fB', c_float),
    # <  Blue，Range[0.0, 1.0]
    ('fAlpha', c_float),
    # <  Alpha，Range[0.0, 1.0](Not Support)
    ('nReserved', c_uint * 4),     # <  Reserved bytes
]
MVCC_COLORF = _MVCC_COLORF

#  Point defined
class _MVCC_POINTF(Structure):
    pass
_MVCC_POINTF._fields_ = [
    ('fX', c_float),
    # <  Distance From Left，Range[0.0, 1.0]
    ('fY', c_float),
    # <  Distance From Top，Range[0.0, 1.0]
    ('nReserved', c_uint * 4),     # <  Reserved bytes
]
MVCC_POINTF = _MVCC_POINTF

#  Rect Area Info
class _MVCC_RECT_INFO(Structure):
    pass
_MVCC_RECT_INFO._fields_ = [
    ('fTop', c_float),
    # <  Distance From Top，Range[0, 1.0]
    ('fBottom', c_float),
    # <  Distance From Bottom，Range[0, 1.0]
    ('fLeft', c_float),
    # <  Distance From Left，Range[0, 1.0]
    ('fRight', c_float),
    # <  Distance From Right，Range[0, 1.0]
    ('stColor', MVCC_COLORF),      # <  Color of Auxiliary Line
    ('nLineWidth', c_uint),        # <  Width of Auxiliary Line, width is 1 or 2
    ('nReserved', c_uint * 4),     # <  Reserved bytes
]
MVCC_RECT_INFO = _MVCC_RECT_INFO

#  Circle Area Info
class _MVCC_CIRCLE_INFO(Structure):
    pass
_MVCC_CIRCLE_INFO._fields_ = [
    ('stCenterPoint', MVCC_POINTF),  # <  Circle Point Info
    ('fR1', c_float),
    # <  Width Radius, Range[0, 1.0]
    ('fR2', c_float),
    # <  Height Radius, Range[0, 1.0]
    ('stColor', MVCC_COLORF),      # <  Color of Auxiliary Line
    ('nLineWidth', c_uint),        # <  Width of Auxiliary Line, width is 1 or 2
    ('nReserved', c_uint * 4),     # <  Reserved bytes
]
MVCC_CIRCLE_INFO = _MVCC_CIRCLE_INFO

#  Linear Auxiliary Line Info
class _MVCC_LINES_INFO(Structure):
    pass
_MVCC_LINES_INFO._fields_ = [
    ('stStartPoint', MVCC_POINTF), # <  The Start Point of Auxiliary Line
    ('stEndPoint', MVCC_POINTF),   # <  The End Point of Auxiliary Line
    ('stColor', MVCC_COLORF),      # <  Color of Auxiliary Line
    ('nLineWidth', c_uint),        # <  Width of Auxiliary Line, width is 1 or 2
    ('nReserved', c_uint * 4),     # <  Reserved bytes
]
MVCC_LINES_INFO = _MVCC_LINES_INFO

#  List of images after image reconstruction
class _MV_OUTPUT_IMAGE_INFO_(Structure):
    pass
_MV_OUTPUT_IMAGE_INFO_._fields_ = [
    ('nWidth', c_uint),                 # <  Image Width
    ('nHeight', c_uint),                # <  Image Height
    ('enPixelType', MvGvspPixelType),   # <  pixel format
    ('pBuf', POINTER(c_ubyte)),      # <  Output data buffer
    ('nBufLen', c_uint),             # <  Output data length
    ('nBufSize', c_uint),            # <  Provided output buffer size
    ('nRes', c_uint * 8),                 # <  Reserved bytes
]
MV_OUTPUT_IMAGE_INFO = _MV_OUTPUT_IMAGE_INFO_

#  Restructure image parameters
class _MV_RECONSTRUCT_IMAGE_PARAM_(Structure):
    pass
_MV_RECONSTRUCT_IMAGE_PARAM_._fields_ = [
    ('nWidth', c_uint),                 # <  Image Width
    ('nHeight', c_uint),                # <  Image Height
    ('enPixelType', MvGvspPixelType),   # <  pixel format
    ('pSrcData', POINTER(c_ubyte)),      # <  input data buffer
    ('nSrcDataLen', c_uint),             # <  input data size
    ('nExposureNum', c_uint),            # <  Exposure number
    ('enReconstructMethod', MV_IMAGE_RECONSTRUCTION_METHOD),   # <  Image restructuring method
    ('stDstBufList', MV_OUTPUT_IMAGE_INFO * MV_MAX_SPLIT_NUM),  # <  Output data info
    ('nRes', c_uint * 4),                 # <  Reserved bytes
]
MV_RECONSTRUCT_IMAGE_PARAM = _MV_RECONSTRUCT_IMAGE_PARAM_

#  File Access
class _MV_CC_FILE_ACCESS_E(Structure):
    pass
_MV_CC_FILE_ACCESS_E._fields_ = [
    ('pUserFileBuf', POINTER(c_char)),  # <  User file data
    ('pFileBufSize', c_uint),  # <  data buffer size
    ('pFileBufLen', c_uint),   # <  data buffer len
    ('pDevFileName', STRING),           # <  Device file name
    ('nReserved', c_uint * 32),         # <  Reserved bytes
]
MV_CC_FILE_ACCESS_EX = _MV_CC_FILE_ACCESS_E

__all__ = ['_MV_ALL_MATCH_INFO_', 'MV_CC_FILE_ACCESS_PROGRESS',
           'N19_MV_CC_DEVICE_INFO_3DOT_0E', 'MV_FRAME_OUT',
           'MV_CAM_GAIN_MODE',
           'MV_ALL_MATCH_INFO',
           'MV_GIGE_TRANSTYPE_UNICAST_WITHOUT_RECV',
           'MV_TRIGGER_SOURCE_LINE0', 'MV_PointCloudFile_Undefined',
           'MV_TRIGGER_SOURCE_LINE2', 'MV_TRIGGER_SOURCE_LINE3',
           'AM_CycleDetect',
           'MV_GrabStrategy_UpcomingImage', 'IFT_IFloat',
           'MV_EVENT_OUT_INFO', 'MV_TRANSMISSION_TYPE',
           'uint_fast16_t', 'MV_CHUNK_DATA_CONTENT','MV_ACTION_CMD_RESULT',
           'MV_CC_INPUT_FRAME_INFO',
           '_MV_ACTION_CMD_RESULT_T',
           'AM_RO', 'IFT_IPort', 'uint_least16_t',
           '_MV_FRAME_OUT_INFO_EX_', '_MV_TRANSMISSION_TYPE_T',
           'MV_SAVE_IMAGE_PARAM_EX', 'MV_SAVE_IMAGE_PARAM_EX3', 'AM_RW', 'MV_XML_InterfaceType',
           'int32_t', '_MV_ACTION_CMD_INFO_T', 'intptr_t',
           'uint_least64_t', '_MV_NETTRANS_INFO_',
           '_MV_CAM_TRIGGER_MODE_', 'int_least32_t',
           'MV_GIGE_TRANSTYPE_SUBNETBROADCAST',
           'MV_SAVE_POINT_CLOUD_FILE_TYPE',
           'MV_ACTION_CMD_RESULT_LIST',
           'MV_BALANCEWHITE_AUTO_CONTINUOUS',
           '_MV_CHUNK_DATA_CONTENT_', 'MV_FormatType_AVI',
           '_MV_CC_PIXEL_CONVERT_PARAM_T_','_MV_PIXEL_CONVERT_PARAM_EX_T_',
           'MV_GENTL_IF_INFO',
           'MV_ACQ_MODE_SINGLE',
           'MV_TRIGGER_MODE_ON',
           'int_least16_t', 'N22_MV_FRAME_OUT_INFO_EX_3DOT_1E',
           'MV_GIGE_TRANSTYPE_LIMITEDBROADCAST', 'int_fast32_t',
           '_MV_CAM_GAIN_MODE_',
           'MV_RECORD_FORMAT_TYPE', 'MV_CC_DEVICE_INFO',
           'IFT_ICommand', '_MV_RECORD_FORMAT_TYPE_',
           '_MV_CAM_ACQUISITION_MODE_',
           '_MVCC_STRINGVALUE_T',
           'MV_GIGE_TRANSTYPE_MULTICAST_WITHOUT_RECV',
           '_MV_MATCH_INFO_NET_DETECT_', 'MVCC_INTVALUE',
           'MV_PointCloudFile_OBJ', '_MV_GIGE_TRANSMISSION_TYPE_',
           '_MV_CC_RECORD_PARAM_T_',
           '_MV_GENTL_IF_INFO_', 'MV_EXPOSURE_MODE_TIMED', 'intmax_t',
           'int16_t',
           'MV_DISPLAY_FRAME_INFO', '_MV_CC_FILE_ACCESS_PROGRESS_T',
           '_MV_GRAB_STRATEGY_', '_MV_SAVE_IMG_TO_FILE_PARAM_', '_MV_SAVE_IMAGE_TO_FILE_PARAM_EX_',
           'int_fast64_t',
           'MV_XML_AccessMode',
           'MV_GAIN_MODE_ONCE', 'IFT_IInteger',
           'MV_CAM_BALANCEWHITE_AUTO', 'int_least8_t',
           'MV_PointCloudFile_CSV', 'IFT_IBase',
           'MV_TRIGGER_MODE_OFF', 'MV_Image_Bmp',
           '_MV_GENTL_DEV_INFO_', 'MV_CC_FILE_ACCESS',
           '_MV_CAM_EXPOSURE_AUTO_MODE_',
           'uint_least8_t',
           'MV_ACTION_CMD_INFO',
           '_MV_CC_INPUT_FRAME_INFO_T_',
           'MV_GENTL_DEV_INFO_LIST', '_MV_CAM_TRIGGER_SOURCE_',
           'MV_GRAB_STRATEGY',
           'IFT_IEnumeration', 'uint64_t', 'uint8_t',
           '_MV_GENTL_DEV_INFO_LIST_',
           'MV_CAM_GAMMA_SELECTOR',
           'MV_CamL_DEV_INFO', 'MV_GENTL_IF_INFO_LIST',
           'MV_CAM_TRIGGER_MODE', 'MV_GIGE_TRANSTYPE_MULTICAST',
           'uint16_t', 'uint_fast8_t',
           '_MV_ACTION_CMD_RESULT_LIST_T',
           '_MV_MATCH_INFO_USB_DETECT_',
           '_MVCC_ENUMVALUE_T',
           'MV_SAVE_POINT_CLOUD_PARAM', '_MV_CC_DEVICE_INFO_',
           'IFT_IBoolean',
           'MV_MATCH_INFO_USB_DETECT', 'MV_PointCloudFile_PLY',
           'MVCC_ENUMVALUE',
           'IFT_IString',
           'MV_ACQ_MODE_CONTINUOUS',
           'MV_TRIGGER_SOURCE_FrequencyConverter',
           'MV_TRIGGER_SOURCE_COUNTER0',
           'MV_GAIN_MODE_OFF', '_MV_CC_DEVICE_INFO_LIST_',
           'MV_GIGE_DEVICE_INFO', '_MV_SAVE_IMAGE_PARAM_T_EX_', '_MV_SAVE_IMAGE_PARAM_EX3_',
           'AM_NA', 'uint_least32_t',
           'MV_CC_PIXEL_CONVERT_PARAM', 'MV_CC_PIXEL_CONVERT_PARAM_EX','AM_NI',
           '_MVCC_INTVALUE_EX_T', 'uintptr_t', 'MV_Image_Tif',
           'MVCC_FLOATVALUE', 'MV_GIGE_TRANSTYPE_CAMERADEFINED',
           '_MV_GENTL_IF_INFO_LIST_', 'MV_NETTRANS_INFO',
           'IFT_IRegister', 'MV_GIGE_TRANSMISSION_TYPE',
           'MV_EXPOSURE_AUTO_MODE_ONCE', 'MV_GIGE_TRANSTYPE_UNICAST',
           'int8_t', '_MV_GIGE_DEVICE_INFO_', 'IFT_IValue', 'AM_WO',
           'int_fast8_t',
           'MV_GAMMA_SELECTOR_SRGB','int_least64_t',
           'MV_GrabStrategy_LatestImagesOnly',
           'MV_EXPOSURE_AUTO_MODE_OFF', 'MV_CAM_EXPOSURE_AUTO_MODE',
           'MV_EXPOSURE_AUTO_MODE_CONTINUOUS',
           'MV_CAM_ACQUISITION_MODE', 'AM_Undefined',
           'MV_MATCH_INFO_NET_DETECT',
           '_MV_CC_FILE_ACCESS_T',
           '_MV_DISPLAY_FRAME_INFO_','MV_GrabStrategy_OneByOne',
           'MV_TRIGGER_SOURCE_SOFTWARE', 'MV_FormatType_Undefined',
           'MV_BALANCEWHITE_AUTO_ONCE',
           'uintmax_t', 'int_fast16_t',
           '_MV_CAM_EXPOSURE_MODE_','MV_BALANCEWHITE_AUTO_OFF',
           'int64_t', 'MV_Image_Undefined', 'MV_GAIN_MODE_CONTINUOUS',
           'uint_fast32_t',
           'MV_CAM_TRIGGER_SOURCE', 'MV_GrabStrategy_LatestImages',
           'MV_Image_Png',
           'MV_Image_Jpeg', '_MV_CamL_DEV_INFO_',
           '_MVCC_FLOATVALUE_T',
           'MV_FRAME_OUT_INFO_EX', '_MV_SAVE_POINT_CLOUD_PARAM_',
           '_MV_CAM_BALANCEWHITE_AUTO_', 'MV_CC_RECORD_PARAM',
           '_MV_USB3_DEVICE_INFO_',
           'MVCC_INTVALUE_EX', 'MV_EXPOSURE_MODE_TRIGGER_WIDTH',
           'MV_GIGE_TRANSTYPE_UNICAST_DEFINED_PORT',
           'MV_SAVE_IAMGE_TYPE','MV_GENTL_DEV_INFO',
           'MV_CAM_EXPOSURE_MODE',
           'MVCC_STRINGVALUE',
           'MvGvspPixelType',
           'MV_CC_DEVICE_INFO_LIST',
           'MV_TRIGGER_SOURCE_LINE1',
           'uint_fast64_t','_MVCC_INTVALUE_T',
           'IFT_ICategory',
           'MV_SAVE_IMG_TO_FILE_PARAM', 'MV_SAVE_IMAGE_TO_FILE_PARAM_EX', '_MV_FRAME_OUT_',
           'MV_GAMMA_SELECTOR_USER',
           'uint32_t', '_MV_CAM_GAMMA_SELECTOR_', 'MV_ACQ_MODE_MUTLI',
           'MV_USB3_DEVICE_INFO', '_MV_EVENT_OUT_INFO_', 'MV_CC_FRAME_SPEC_INFO', 'MV_CC_HB_DECODE_PARAM',
           'MV_SORT_METHOD', '_MV_SORT_METHOD_',
           'SortMethod_SerialNumber', 'SortMethod_UserID', 'SortMethod_CurrentIP_ASC', 'SortMethod_CurrentIP_DESC',
           '_MV_IMG_ROTATION_ANGLE_', 'MV_IMG_ROTATION_ANGLE',
           'MV_IMAGE_ROTATE_90', 'MV_IMAGE_ROTATE_180', 'MV_IMAGE_ROTATE_270',
           '_MV_IMG_FLIP_TYPE_', 'MV_IMG_FLIP_TYPE', 'MV_FLIP_VERTICAL', 'MV_FLIP_HORIZONTAL',
           '_MV_CC_GAMMA_TYPE_', 'MV_CC_GAMMA_TYPE', 'MV_CC_GAMMA_TYPE_NONE', 'MV_CC_GAMMA_TYPE_VALUE',
           'MV_CC_GAMMA_TYPE_USER_CURVE', 'MV_CC_GAMMA_TYPE_LRGB2SRGB', 'MV_CC_GAMMA_TYPE_SRGB2LRGB',
           'MV_CC_STREAM_EXCEPTION_TYPE', '_MV_CC_STREAM_EXCEPTION_TYPE_',
           'MV_CC_STREAM_EXCEPTION_ABNORMAL_IMAGE', 'MV_CC_STREAM_EXCEPTION_LIST_OVERFLOW',
           'MV_CC_STREAM_EXCEPTION_LIST_EMPTY', 'MV_CC_STREAM_EXCEPTION_RECONNECTION',
           'MV_CC_STREAM_EXCEPTION_DISCONNECTED', 'MV_CC_STREAM_EXCEPTION_DEVICE',
           '_MV_IMAGE_RECONSTRUCTION_METHOD_', 'MV_IMAGE_RECONSTRUCTION_METHOD', 'MV_SPLIT_BY_LINE',
           'MVCC_COLORF', '_MVCC_COLORF', '_MVCC_POINTF', 'MVCC_POINTF', '_MVCC_RECT_INFO', 'MVCC_RECT_INFO',
           '_MVCC_CIRCLE_INFO', 'MVCC_CIRCLE_INFO', '_MVCC_LINES_INFO', 'MVCC_LINES_INFO', '_MV_OUTPUT_IMAGE_INFO_',
           'MV_OUTPUT_IMAGE_INFO', 'MV_RECONSTRUCT_IMAGE_PARAM', '_MV_RECONSTRUCT_IMAGE_PARAM_',
           '_MVCC_ENUMENTRY_T', 'MVCC_ENUMENTRY','_MV_CC_CONTRAST_PARAM_T_', 'MV_CC_CONTRAST_PARAM_T',
           '_MV_CC_CCM_PARAM_EX_T_', 'MV_CC_CCM_PARAM_EX', 'MV_CC_CCM_PARAM', '_MV_CC_CCM_PARAM_T_',
           'MV_CC_GAMMA_PARAM', '_MV_CC_GAMMA_PARAM_T_', 'MV_CC_FLIP_IMAGE_PARAM', '_MV_CC_FLIP_IMAGE_PARAM_T_',
           '_MV_CC_ROTATE_IMAGE_PARAM_T_', 'MV_CC_ROTATE_IMAGE_PARAM', 'MV_CC_FILE_ACCESS_EX', '_MV_CC_FILE_ACCESS_E',
           '_MV_DISPLAY_FRAME_INFO_EX_', 'MV_DISPLAY_FRAME_INFO_EX']
